/*******************************************************************************
 *  Copyright 2011 maidsafe.net limited                                        *
 *                                                                             *
 *  The following source code is property of maidsafe.net limited and is not   *
 *  meant for external use.  The use of this code is governed by the licence   *
 *  file licence.txt found in the root of this directory and also on           *
 *  www.maidsafe.net.                                                          *
 *                                                                             *
 *  You are not free to copy, amend or otherwise use this source code without  *
 *  the explicit written permission of the board of directors of maidsafe.net. *
 *******************************************************************************
 */


#include "maidsafe/drive/share_users.h"

#include "maidsafe/common/log.h"
#include "maidsafe/common/utils.h"

#include "maidsafe/drive/return_codes.h"
#include "maidsafe/drive/proto_structs_pb.h"

namespace maidsafe {

namespace drive {

namespace share_users {

namespace {

bool Serialise(const std::map<std::string, int>& all_share_users, std::string& serialised_users) {
  if (all_share_users.empty()) {
    LOG(kError) << "Empty users shouldn't really be serialised. Could just delete the file.";
    return true;
  }

  protobuf::ShareMembers share_members;
  for (auto& member: all_share_users) {
    protobuf::ShareMemberData* share_member_data = share_members.add_member();
    share_member_data->set_member_id(member.first);
    share_member_data->set_membership_state(member.second);
  }

  if (!share_members.SerializeToString(&serialised_users)) {
    LOG(kError) << "Failed to serialise share members.";
    return false;
  }

  return true;
}

bool Parse(const std::string& serialised_users, std::map<std::string, int>& all_share_users) {
  if (serialised_users.empty()) {
    LOG(kError) << "What is the point of this?";
    return true;
  }

  protobuf::ShareMembers share_members;
  if (!share_members.ParseFromString(serialised_users)) {
    LOG(kError) << "Failed to parse share members.";
    return false;
  }

  if (share_members.member_size() == 0)
    LOG(kWarning) << "Share members empty! Why did we store this in the first place?";

  for (int n(0); n < share_members.member_size(); ++n) {
    int32_t m(share_members.member(n).membership_state());
    int nnn(static_cast<int>(m));
    // TODO(Team): Map behaving weirdly when using insert. WTF!!! Check it out after launch.
    all_share_users[share_members.member(n).member_id()] = nnn;
  }

  return true;
}

}  // unnamed namespace


int Add(const std::map<std::string, int>& share_users,
        const std::string& serialised_existing_users,
        std::string& serialised_updated_users) {
  std::map<std::string, int> users;
  if (!Parse(serialised_existing_users, users)) {
    LOG(kError) << "Failed to parse share users.";
    serialised_updated_users.clear();
    return kFailedToParseShareUsers;
  }

  // merge of two map can be used here, if don't care about duplicated users
  for (auto it : share_users) {
    auto result(users.insert(std::make_pair(it.first,
                                            it.second == kShareOwner ?
                                                  it.second :
                                                  it.second - kShareConfirmationFactor)));
    if (!result.second)
      LOG(kWarning) << "User " << Base64Substr(it.first) << " already exists.";
  }

  if (!Serialise(users, serialised_updated_users)) {
    LOG(kError) << "Failed to serialise share users.";
    return kFailedToSerialiseShareUsers;
  }

  return kSuccess;
}

bool GetAll(const std::string& serialised_users, std::map<std::string, int>& all_share_users) {
  return Parse(serialised_users, all_share_users);

  // filter out un-confirmed users shall only be done on the highest level
//   std::vector<std::string> unconfirmed_users;
//   for (auto it = all_share_users->begin(); it != all_share_users->end(); ++it)
//     if ((*it).second < kShareRemover)
//       unconfirmed_users.push_back((*it).first);
//   for (auto it = unconfirmed_users.begin(); it != unconfirmed_users.end(); ++it)
//     all_share_users->erase(*it);
}

int Remove(const std::vector<std::string>& user_ids,
           const std::string& serialised_existing_users,
           std::string& serialised_updated_users) {
  std::map<std::string, int> users;
  if (!Parse(serialised_existing_users, users)) {
    LOG(kError) << "Failed to parse share users.";
    serialised_updated_users.clear();
    return kFailedToParseShareUsers;
  }

  for (auto it = user_ids.begin(); it != user_ids.end(); ++it)
    users.erase(*it);

  if (!Serialise(users, serialised_updated_users)) {
    LOG(kError) << "Failed to serialise share users.";
    return kFailedToSerialiseShareUsers;
  }

  return kSuccess;
}

int Confirm(const std::vector<std::string>& user_ids,
            const std::string& serialised_existing_users,
            std::string& serialised_updated_users) {
  std::map<std::string, int> users;
  if (!Parse(serialised_existing_users, users)) {
    LOG(kError) << "Failed to parse share users.";
    serialised_updated_users.clear();
    return kFailedToParseShareUsers;
  }

  for (auto it = user_ids.begin(); it != user_ids.end(); ++it)
    if (users[*it] < kShareRemover)
      users[*it] += kShareConfirmationFactor;

  if (!Serialise(users, serialised_updated_users)) {
    LOG(kError) << "Failed to serialise share users.";
    return kFailedToSerialiseShareUsers;
  }

  return kSuccess;
}

int GetUserRights(const std::string& user_id,
                  const std::string& serialised_users,
                  int& admin_rights) {
  std::map<std::string, int> users;
  if (!Parse(serialised_users, users)) {
    LOG(kError) << "Failed to parse share users.";
    return kFailedToParseShareUsers;
  }

  auto itr(users.find(user_id));
  if (itr == users.end()) {
    LOG(kError) << "Failed to find share user " << Base64Substr(user_id);
    return kFailedToFindShareUser;
  }

  admin_rights = (*itr).second;
  return kSuccess;
}

int SetUserRights(const std::string& user_id,
                  int admin_rights,
                  const std::string& serialised_existing_users,
                  std::string& serialised_updated_users) {
  std::map<std::string, int> users;
  if (!Parse(serialised_existing_users, users)) {
    LOG(kError) << "Failed to parse share users.";
    return kFailedToParseShareUsers;
  }

  auto itr(users.find(user_id));
  if (itr == users.end()) {
    LOG(kError) << "Failed to find share user " << Base64Substr(user_id);
    return kFailedToFindShareUser;
  }

  (*itr).second = admin_rights;

  if (!Serialise(users, serialised_updated_users)) {
    LOG(kError) << "Failed to serialise share users.";
    return kFailedToSerialiseShareUsers;
  }

  return kSuccess;
}

}  // namespace share_users

}  // namespace drive

}  // namespace maidsafe
